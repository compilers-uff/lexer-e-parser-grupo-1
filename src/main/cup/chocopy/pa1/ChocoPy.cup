import java.util.ArrayList;
import java.util.List;

import java_cup.runtime.*;
import chocopy.common.astnodes.*;

/* The following code section is copied verbatim to the generated
 * parser class. */
parser code {:

    /* The following fields and methods deal with error reporting
     * Avoid changing these unless you know what you are doing. */

    /** Node that accumulates error messages to be added to the Program
     *  node produced as a result. */
    public final Errors errors = new Errors(new ArrayList<>());

    /* Debug Attribute */
    public boolean debug = false;

    /* Scanner Output */
    public String tokens = "";

    /** Return the Program node that results from parsing the stream of
     *  tokens produced by lexical analysis.  In the case of syntax errors,
     *  the program may be empty, but will have error messages. */
    public Program parseProgram(boolean debug) {
        try {
            Symbol result = debug ? debug_parse() : parse();

            // If the scanner is in debug mode, print the scanned tokens
            if (debug) {
                System.out.println("\n# SCANNER OUTPUT:\n" + tokens + "\n");
            }

            if (result == null || !(result.value instanceof Program)) {
                return new Program(new Location(0, 0), new Location(0, 0),
                                   new ArrayList<Declaration>(),
                                   new ArrayList<Stmt>(),
                                   errors);
            } else {
                return (Program) result.value;
            }
        } catch (RuntimeException excp) {
            throw excp;
        } catch (Exception excp) {
            String msg =
                String.format("Internal parser error detected: %s%n", excp);
            throw new AssertionError(msg);
        }
    }

    @Override
    public SymbolFactory getSymbolFactory() {
        return ((ChocoPyLexer) getScanner()).symbolFactory;
    }

    @Override
    public Symbol parse() throws Exception { // Overridden to allow debugging of tokens
        this.debug = false;
        return super.parse();
    }

    @Override
    public Symbol debug_parse() throws Exception { // Overridden to allow debugging of tokens
        this.debug = true;
        return super.debug_parse();
    }

    @Override
    public Symbol scan() throws Exception { // Overridden to allow debugging of tokens
        Symbol sym = super.scan();

        // If the scanner is in debug mode, print the token
        if (debug) {
            Integer tokenId = sym.sym;
            String tokenName = ChocoPyTokens.terminalNames[tokenId];
            String token = sym.value == null ? tokenName : tokenName + "(" + sym.value.toString() + ")";
            token = token.replaceAll("\n", "\\\\n");
            tokens += token + " ";
            
            // Add a newline for NEWLINE tokens
            if (tokenId == ChocoPyTokens.NEWLINE) {
                tokens += "\n";
            }
        }

        return sym;
    }

    @Override
    public void syntax_error(Symbol cur_token) {
                String token = symbl_name_from_id(cur_token.sym);
                String text = ((ChocoPyLexer) getScanner()).yytext();
                errors.syntaxError(
                    ((ComplexSymbolFactory.ComplexSymbol) cur_token).xleft,
                    ((ComplexSymbolFactory.ComplexSymbol) cur_token).xright,
                    "Parse error near token %s: %s", token, text);
    }

    @Override
    public void unrecovered_syntax_error(Symbol cur_token) {
        /* Do not die */
    }
:}


/**************************************************************************
 *              FEEL FREE TO MODIFY ANYTHING BELOW THIS LINE              
 *
 * The rules provided below parse expressions of the form <INT> + <INT> + ... 
 * You can re-use these rules or edit them as you wish. The start rule
 * should return a node of type Program.
 *
 * Tips: Production rules are usually followed by action code that will be
 * copied to the generated parser to be executed immediately after a reduce
 * operation; that is, when a production rule has been matched. You can name
 * a nonterminal or terminal symbol in a production rule using the colon
 * notation, e.g. expr_stmt ::= expr:e, to get the AST node for the matched
 * expression. In the action code, `e` will be a variable of whatever type
 * has been declared for the corresponding nonterminal, such as `Expr`.
 * Therefore, you can construct an AST Node of type `ExprStmt` with `e` in the
 * constructor: `new ExprStmt(exleft, exright, e)`
 *
 * The variables `exleft` and `exright` are automatically generated by CUP
 * and contain Location objects for the start and end of the expression `e`.
 * You can collect start and line number info for AST nodes by taking the
 * location of the left end of the leftmost symbol in a rule and the
 * location of the right end of the rightmost symbol. The auto-generated
 * variables have names `<sym>xleft` and `<sym>xright`, where <sym> is the
 * name given to the symbol using the colon notation.
 *
 * When you have nonterminals that are lists of things, e.g. List<Stmt> or
 * List<Declaration>, it is helpful to get the leftmost and rightmost
 * source location from within this list; we have provided some utility
 * functions below to do just that.
 **************************************************************************/


/* The following code section is copied verbatim to the class that performs
 * production-rule actions. */
action code {:

    /** Return a mutable list initially containing the single value ITEM. */
    <T> List<T> single(T item) {
        List<T> list = new ArrayList<>();
        if (item != null) {
            list.add(item);
        }
        return list;
    }

    /** If ITEM is non-null, appends it to the end of LIST.  Then returns
     *  LIST. */
    <T> List<T> combine(List<T> list, T item) {
        if (item != null) {
            list.add(item);
        }
        return list;
    }

    /** Return a mutable empty list. */
    <T> List<T> empty() {
        return new ArrayList<T>();
    }

    /** Return the leftmost non-whitespace location in NODES, or null if NODES
     *  is empty.  Assumes that the nodes of NODES are ordered in increasing
     *  order of location, from left to right. */
    ComplexSymbolFactory.Location getLeft(List<? extends Node> nodes) {
        if (nodes.isEmpty()) {
            return null;
        }
        Node first = nodes.get(0);
        return new ComplexSymbolFactory.Location(first.getLocation()[0],
                                                 first.getLocation()[1]);
    }

    /** Return the rightmost non-whitespace location in NODES, or null if NODES
     *  is empty.  Assumes that the nodes of NODES are ordered in increasing
     *  order of location, from left to right. */
    ComplexSymbolFactory.Location getRight(List<? extends Node> nodes) {
        if (nodes.isEmpty()) {
            return null;
        }
        Node last = nodes.get(nodes.size()-1);
        return new ComplexSymbolFactory.Location(last.getLocation()[2],
                                                 last.getLocation()[3]);
    }
:}

/* Terminal symbols (tokens returned by the lexer).  The declaration
 *     terminal <identifier1>, <identifier2>, ...;
 * declares each <identifieri> as the denotation of a distinct type terminal
 * symbol for use in the grammar.  The declaration
 *     terminal <type> <identifier1>, ...;
 * does the same, and in addition indicates that the lexer supplies a
 * semantic value of type <type> for these symbols that may be referenced
 * in actions ( {: ... :} ).
 */

 /* Line Delimiters. */
terminal NEWLINE, INDENT, DEDENT;

/* Identifiers */
terminal String ID;

/* Keywords */
terminal String GLOBAL, NONLOCAL, LAMBDA, AS, ASSERT, AWAIT, BREAK, CONTINUE, DEL, EXCEPT, FINALLY, FROM, IMPORT, RAISE, TRY, WITH, YIELD;

/* Definitions */
terminal String EQUAL, CLASS, DEF;

/* Statements */
terminal String IF, ELIF, ELSE, WHILE, FOR, PASS, RETURN;

/* Literals */
terminal String NONE;
terminal String TRUE, FALSE;
terminal Integer NUMBER;

/* String Literals */
terminal String STRING;

/* Logic Operators */
terminal String IN, NOT, AND, OR, IS;

/* Arithmetic Operators */
terminal String PLUS, MINUS, MULTIPLY, DIVIDE, MOD, EQUALEQUAL, NOTEQUAL, LTE, GTE, LT, GT, UMINUS;

/* Punctuation */
terminal String DOT, COMMA, COLON, ARROW, LPAREN, RPAREN, LBRACKET, RBRACKET;

/* Returned by the lexer for erroneous tokens.  Since it does not appear in
 * the grammar, it indicates a syntax error. */
terminal UNRECOGNIZED;   

/* Nonterminal symbols (defined in production rules below).
 * As for terminal symbols, 
 *     non terminal <type> <identifier1>, ..., <identifiern>; 
 * defines the listed nonterminal identifier symbols to have semantic values
 * of type <type>. */
non terminal Program            program;
non terminal List<Declaration>  program_head;
non terminal List<Stmt>         stmt_list, opt_stmt_list;
non terminal Stmt               stmt;
non terminal Expr               expr, binary_expr;
non terminal Identifier         id;
non terminal ClassDef           class_definition;
non terminal FuncDef            function_definition;
non terminal List<Declaration>  class_body, function_body;
non terminal TypedVar           typed_variable;
non terminal List<TypedVar>     list_tp;
non terminal TypeAnnotation     type;
non terminal Declaration        global_definition, nonlocal_definition;
non terminal VarDef             var_definition;
non terminal List<Stmt>         block;
non terminal IndexExpr          index_expr;
non terminal MemberExpr         member_expr;
non terminal Literal            literal;
non terminal Stmt               stmt_simple;
non terminal List<Stmt>         elif_expression, else_expression;
non terminal Expr               cexpr, target;
non terminal List<Expr>         expr_list, target_aux;

/* Precedences (lowest to highest) for resolving what would otherwise be
 * ambiguities in the form of shift/reduce conflicts.. */
precedence right IF, ELSE;
precedence left OR;
precedence left AND;
precedence left NOT;
precedence nonassoc EQUALEQUAL, NOTEQUAL, LT, GT, LTE, GTE, IS;
precedence left PLUS, MINUS;
precedence left MULTIPLY, DIVIDE, MOD;
precedence left UMINUS;
precedence left DOT, COMMA, LBRACKET, RBRACKET;

/* The start symbol. */
start with program;


/*****  GRAMMAR RULES *****/

program ::= program_head:d opt_stmt_list:s {:
                RESULT = new Program(d.isEmpty() ? getLeft(s) : getLeft(d), sxright, d, s, errors);
            :};

/* Initial list of declarations. */
program_head ::=                                        {: RESULT = empty(); :}
               | NEWLINE                                {: RESULT = empty();:}
               | program_head:ph error:e                {: RESULT = ph; :}
               | program_head:ph var_definition:vd      {: RESULT = combine(ph, vd); :}
               | program_head:ph function_definition:fd {: RESULT = combine(ph, fd); :}
               | program_head:ph class_definition:cd    {: RESULT = combine(ph, cd); :};

/* Identifier */
id ::= ID:id {: RESULT = new Identifier(idxleft, idxright, id); :};

/* Class Definition */
class_definition ::= CLASS:cl id:identifier LPAREN id:identifier_root RPAREN COLON NEWLINE INDENT class_body:cb DEDENT {:
                        RESULT = new ClassDef(clxleft, getRight(cb), identifier, identifier_root, cb);
                    :};

class_body ::= PASS:pass NEWLINE                             {: RESULT = empty(); :}
             | class_body:class_b error:error                {: RESULT = class_b; :}
             | var_definition:var_d                          {: RESULT = single(var_d); :}
             | function_definition:func_d                    {: RESULT = single(func_d); :}
             | class_body:class_b var_definition:var_d       {: RESULT = combine(class_b, var_d); :}
             | class_body:class_b function_definition:func_d {: RESULT = combine(class_b, func_d); :};

/* Function Definition */
function_definition ::= DEF:def id:identifier LPAREN list_tp:lt RPAREN COLON:c NEWLINE INDENT function_body:func_b stmt_list:stmt DEDENT {:
                            RESULT = new FuncDef(defxleft, getLeft(stmt), identifier, lt, new ClassType(cxleft, cxright, "<None>"), func_b, stmt);
                        :}
                      | DEF:def id:identifier LPAREN list_tp:lt RPAREN ARROW type:ty COLON NEWLINE INDENT function_body:func_b stmt_list:stmt DEDENT {:
                            RESULT = new FuncDef(defxleft, getRight(stmt), identifier, lt, ty, func_b, stmt);
                        :};

function_body ::=                                                 {: RESULT = empty(); :}
                | function_body:func_b error:error                {: RESULT = func_b; :}
                | function_body:func_b global_definition:glob_d   {: RESULT = combine(func_b, glob_d); :}
                | function_body:func_b nonlocal_definition:nonl_d {: RESULT = combine(func_b, nonl_d); :}
                | function_body:func_b var_definition:var_d       {: RESULT = combine(func_b, var_d); :}
                | function_body:func_b function_definition:func_d {: RESULT = combine(func_b, func_d); :};

/* Function Arguments */
list_tp ::=                                        {: RESULT = empty(); :}
          | list_tp:lt COMMA error                 {: RESULT = lt; :}
          | typed_variable:type_v                  {: RESULT = single(type_v); :}
          | list_tp:lt COMMA typed_variable:type_v {: RESULT = combine(lt, type_v); :};

/* Typed Variable */
typed_variable ::= id:identifier COLON type:t {: RESULT = new TypedVar(identifierxleft, txright, identifier, t); :};

/* Type */
type ::= id:identifier            {: RESULT = new ClassType(identifierxleft, identifierxright, identifier.name); :}
       | NONE:n                   {: RESULT = new ClassType(nxleft, nxright, n); :}
       | TRUE:t                   {: RESULT = new ClassType(txleft, txright, t); :}
       | FALSE:f                  {: RESULT = new ClassType(fxleft, fxright, f); :}
       | STRING:s                 {: RESULT = new ClassType(sxleft, sxright, s); :}
       | LBRACKET type:t RBRACKET {: RESULT = new ListType(txleft, txright, t); :};

/* Global and Nonlocal Variables */
global_definition ::= GLOBAL:global id:identifier NEWLINE       {: RESULT = new GlobalDecl(globalxleft, globalxright, identifier); :};
nonlocal_definition ::= NONLOCAL:nonlocal id:identifier NEWLINE {: RESULT = new NonLocalDecl(nonlocalxleft, nonlocalxright, identifier); :};

/* Variable Definition */
var_definition ::= typed_variable:ty_var EQUAL literal:literal NEWLINE {: RESULT = new VarDef(ty_varxleft, literalxright, ty_var, literal); :};

/* Statements */
opt_stmt_list ::=             {: RESULT = empty(); :}
                | stmt_list:s {: RESULT = s; :};

stmt_list ::= PASS:pass NEWLINE            {: RESULT = empty(); :}
            | stmt_list:stmt_l error:error {: RESULT = stmt_l; :}
            | stmt:stmt                    {: RESULT = single(stmt); :} 
            | stmt_list:stmt_l stmt:stmt   {: RESULT = combine(stmt_l, stmt); :};

stmt ::= stmt_simple:s NEWLINE                                   {: RESULT = s; :}       
       | IF:i expr:expr COLON block:block                        {: RESULT = new IfStmt(ixleft, getRight(block), expr, block, empty()); :}
       | IF:i expr:expr COLON block:block elif_expression:elif_e {: RESULT = new IfStmt(ixleft, getRight(elif_e), expr, block, elif_e); :}
       | WHILE:w expr:expr COLON block:block                     {: RESULT = new WhileStmt(wxleft, getRight(block), expr, block); :}
       | FOR:f id:identifier IN expr:expr COLON block:block      {: RESULT = new ForStmt(fxleft, getRight(block), identifier, expr, block); :};

stmt_simple ::= PASS:pass NEWLINE             {: RESULT = null; :} 
              | expr:expr                     {: RESULT = new ExprStmt(exprxleft, exprxright, expr); :}
              | RETURN:re                     {: RESULT = new ReturnStmt(rexleft, rexright, null); :}
              | RETURN:re expr:e              {: RESULT = new ReturnStmt(rexleft, exright, e); :}
              | target_aux:target_a expr:expr {: RESULT = new AssignStmt(getLeft(target_a), exprxright, target_a, expr); :};

target_aux ::= target:t EQUAL                     {: RESULT = single(t); :}
             | target_aux:target_a target:t EQUAL {: RESULT = combine(target_a, t); :}; 

/* Conditionals Definition */
elif_expression ::= ELIF:el expr:expr COLON block:block                        {: RESULT = single(new IfStmt(elxleft, getRight(block), expr, block, empty())); :}
                  | ELIF:el expr:expr COLON block:block elif_expression:elif_e {: RESULT = single(new IfStmt(elxleft, getRight(elif_e), expr, block, elif_e)); :}
                  | else_expression:else_e                                     {: RESULT = else_e; :};

else_expression ::= ELSE COLON block:block                                     {: RESULT = block; :};

/* Block */
block ::= NEWLINE INDENT stmt_list:stmt_l DEDENT {: RESULT = stmt_l; :};

/* Literals */
literal ::= NONE:n   {: RESULT = new NoneLiteral(nxleft, nxright); :}
          | TRUE:t   {: RESULT = new BooleanLiteral(txleft, txright, true); :}
          | FALSE:f  {: RESULT = new BooleanLiteral(fxleft, fxright, false); :}
          | NUMBER:n {: RESULT = new IntegerLiteral(nxleft, nxright, n); :}
          | STRING:s {: RESULT = new StringLiteral(sxleft, sxright, s); :};

/* Expressions */
expr ::= cexpr:cexpr                                 {: RESULT = cexpr; :}
       | binary_expr:be                              {: RESULT = be; :}
       | expr:expr_1 IF expr:expr_2 ELSE expr:expr_3 {: RESULT = new IfExpr(expr_1xleft, expr_3xright, expr_2, expr_1, expr_3); :};

cexpr ::= id:identifier                                       {: RESULT = identifier; :}
       | literal:literal                                      {: RESULT = literal; :}
       | LBRACKET:lb expr_list:ex_l RBRACKET:rb               {: RESULT = new ListExpr(lbxleft, rbxright, ex_l); :}
       | LPAREN expr:expr RPAREN                              {: RESULT = expr; :}
       | member_expr:member_e                                 {: RESULT = member_e; :}
       | index_expr:index_e                                   {: RESULT = index_e; :}
       | member_expr:member_e LPAREN expr_list:ex_l RPAREN:rp {: RESULT = new MethodCallExpr(member_exleft, rpxright, member_e, ex_l); :}
       | id:identifier LPAREN expr_list:expr_l RPAREN:rp      {: RESULT = new CallExpr(identifierxleft, rpxright, identifier, expr_l); :}
       | NOT expr:expr                                        {: RESULT = new UnaryExpr(exprxleft, exprxright, "not", expr); :}
       | MINUS:op expr:expr                                   {: RESULT = new UnaryExpr(opxleft, exprxright, op, expr); :} %prec UMINUS;

member_expr ::= cexpr:cexpr DOT id:identifier {: RESULT = new MemberExpr(cexprxleft, identifierxright, cexpr, identifier); :};

index_expr ::= cexpr:cexpr LBRACKET expr:expr RBRACKET {: RESULT = new IndexExpr(cexprxleft, exprxright, cexpr, expr); :};

target ::= id:identifier         {: RESULT = identifier; :}
          | member_expr:member_e {: RESULT = member_e; :}
          | index_expr:index_e   {: RESULT = index_e; :};

/* Expressions Lists */
expr_list ::=                                  {: RESULT = empty(); :}
            | expr_list:expr_l error:error     {: RESULT = expr_l; :}
            | expr:expr                        {: RESULT = single(expr); :}
            | expr_list:expr_l COMMA expr:expr {: RESULT = combine(expr_l, expr); :};

/* Binary Operations */
binary_expr ::= expr:e1 PLUS:op expr:e2       {: RESULT = new BinaryExpr(e1xleft, e2xright, e1, op, e2); :}
              | expr:e1 MINUS:op expr:e2      {: RESULT = new BinaryExpr(e1xleft, e2xright, e1, op, e2); :}
              | expr:e1 MULTIPLY:op expr:e2   {: RESULT = new BinaryExpr(e1xleft, e2xright, e1, op, e2); :}
              | expr:e1 DIVIDE:op expr:e2     {: RESULT = new BinaryExpr(e1xleft, e2xright, e1, op, e2); :}
              | expr:e1 MOD:op expr:e2        {: RESULT = new BinaryExpr(e1xleft, e2xright, e1, op, e2); :}
              | expr:e1 EQUALEQUAL:op expr:e2 {: RESULT = new BinaryExpr(e1xleft, e2xright, e1, op, e2); :}
              | expr:e1 NOTEQUAL:op expr:e2   {: RESULT = new BinaryExpr(e1xleft, e2xright, e1, op, e2); :}
              | expr:e1 LT:op expr:e2         {: RESULT = new BinaryExpr(e1xleft, e2xright, e1, op, e2); :}
              | expr:e1 GT:op expr:e2         {: RESULT = new BinaryExpr(e1xleft, e2xright, e1, op, e2); :}
              | expr:e1 GTE:op expr:e2        {: RESULT = new BinaryExpr(e1xleft, e2xright, e1, op, e2); :}
              | expr:e1 LTE:op expr:e2        {: RESULT = new BinaryExpr(e1xleft, e2xright, e1, op, e2); :}
              | expr:e1 IS:op expr:e2         {: RESULT = new BinaryExpr(e1xleft, e2xright, e1, op, e2); :}
              | expr:e1 OR:op expr:e2         {: RESULT = new BinaryExpr(e1xleft, e2xright, e1, op, e2); :}
              | expr:e1 AND:op expr:e2        {: RESULT = new BinaryExpr(e1xleft, e2xright, e1, op, e2); :};
